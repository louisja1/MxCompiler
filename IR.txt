void @GlobalDeclaration() { 
	@GlobalDeclaration.0.enter :
		jump @GlobalDeclaration.1.exit
	@GlobalDeclaration.1.exit :
}
func main() { 
	main.0.enter :
		call getString
		mov $t1(null) $t0(rax)
		mov $t3(rdi) $t1(null)
		call _builtin_parseint
		mov $t4(null) $t2(rax)
		mov Address($n(@n) + 0) $t4(null)
		mov $t6(null) Address($n(@n) + 0)
		INC $t6(null)
		SHL $t6(null) 3
		$t5(null) = allocate $t6(null)
		mov $t7(null) Address($n(@n) + 0)
		mov Address($t5(null) + 0) $t7(null)
		ADD $t5(null) 8
		mov Address($a(@a) + 0) $t5(null)
		mov $i(null) 0
		jump main.1.loop_condition
	main.1.loop_condition :
		mov $t9(rdi) Address($a(@a) + 0)
		call _builtin_size
		mov $t10(null) $t8(rax)
		cmp $i(null) $t10(null)
		set LE $t11(null)
		cmp $t11(null) 1
		cjump EQ main.2.loop_body
		jump main.4.loop_exit
	main.2.loop_body :
		mov $t12(null) $i(null)
		SHL $t12(null) 3
		mov $t13(null) Address($a(@a) + 0)
		ADD $t13(null) $t12(null)
		mov Address($t13(null) + 0) $i(null)
		jump main.3.loop_next
	main.3.loop_next :
		mov $t14(null) $i(null)
		ADD $t14(null) 1
		mov $i(null) $t14(null)
		jump main.1.loop_condition
	main.4.loop_exit :
		call makeHeap
		mov $t16(null) $t15(rax)
		call heapSort
		mov $t18(null) $t17(rax)
		mov $i(null) 0
		jump main.5.loop_condition
	main.5.loop_condition :
		mov $t20(rdi) Address($a(@a) + 0)
		call _builtin_size
		mov $t21(null) $t19(rax)
		cmp $i(null) $t21(null)
		set LE $t22(null)
		cmp $t22(null) 1
		cjump EQ main.6.loop_body
		jump main.8.loop_exit
	main.6.loop_body :
		mov $t23(null) $i(null)
		SHL $t23(null) 3
		mov $t24(null) Address($a(@a) + 0)
		ADD $t24(null) $t23(null)
		mov $t26(rdi) Address($t24(null) + 0)
		call toString
		mov $t27(null) $t25(rax)
		mov $t29(rdi) $t27(null)
		mov $t30(rsi) _string_constant_0
		call _builtin_add _string_constant_0
		mov $t31(null) $t28(rax)
		mov $t32(rdi) $t31(null)
		call print
		jump main.7.loop_next
	main.7.loop_next :
		mov $t33(null) $i(null)
		ADD $t33(null) 39997
		mov $i(null) $t33(null)
		jump main.5.loop_condition
	main.8.loop_exit :
		mov $t34(rdi) _string_constant_1
		call print
		ret 0
		jump main.9.exit
	main.9.exit :
}
void exchange(x, y) { 
	exchange.0.enter :
		mov $x(null) $t55(rdi)
		mov $y(null) $t56(rsi)
		mov $t57(null) $x(null)
		SHL $t57(null) 3
		mov $t58(null) Address($a(@a) + 0)
		ADD $t58(null) $t57(null)
		mov $t(null) Address($t58(null) + 0)
		mov $t59(null) $x(null)
		SHL $t59(null) 3
		mov $t60(null) Address($a(@a) + 0)
		ADD $t60(null) $t59(null)
		mov $t61(null) $y(null)
		SHL $t61(null) 3
		mov $t62(null) Address($a(@a) + 0)
		ADD $t62(null) $t61(null)
		mov $t63(null) Address($t62(null) + 0)
		mov Address($t60(null) + 0) $t63(null)
		mov $t64(null) $y(null)
		SHL $t64(null) 3
		mov $t65(null) Address($a(@a) + 0)
		ADD $t65(null) $t64(null)
		mov Address($t65(null) + 0) $t(null)
		jump exchange.1.exit
	exchange.1.exit :
}
func adjustHeap(n) { 
	adjustHeap.0.enter :
		mov $n(null) $t66(rdi)
		mov $i(null) 0
		mov $j(null) 0
		mov $t(null) 0
		jump adjustHeap.1.loop_condition
	adjustHeap.1.loop_condition :
		mov $t67(null) $i(null)
		SHL $t67(null) 1
		cmp $t67(null) $n(null)
		set LE $t68(null)
		cmp $t68(null) 1
		cjump EQ adjustHeap.2.loop_body
		jump adjustHeap.12.loop_exit
	adjustHeap.2.loop_body :
		mov $t69(null) $i(null)
		SHL $t69(null) 1
		mov $j(null) $t69(null)
		mov $t70(null) $i(null)
		SHL $t70(null) 1
		mov $t71(null) $t70(null)
		ADD $t71(null) 1
		cmp $t71(null) $n(null)
		set LE $t72(null)
		cmp $t72(null) 1
		cjump EQ adjustHeap.3.logic_true
		jump adjustHeap.4.logic_false
	adjustHeap.3.logic_true :
		mov $t74(null) $i(null)
		SHL $t74(null) 1
		mov $t75(null) $t74(null)
		ADD $t75(null) 1
		mov $t76(null) $t75(null)
		SHL $t76(null) 3
		mov $t77(null) Address($a(@a) + 0)
		ADD $t77(null) $t76(null)
		mov $t78(null) $i(null)
		SHL $t78(null) 1
		mov $t79(null) $t78(null)
		SHL $t79(null) 3
		mov $t80(null) Address($a(@a) + 0)
		ADD $t80(null) $t79(null)
		mov $t82(null) Address($t77(null) + 0)
		cmp $t82(null) Address($t80(null) + 0)
		set LE $t81(null)
		mov $t73(null) $t81(null)
		jump adjustHeap.5.logic_exit
	adjustHeap.4.logic_false :
		mov $t73(null) 0
		jump adjustHeap.5.logic_exit
	adjustHeap.5.logic_exit :
		cmp $t73(null) 1
		cjump EQ adjustHeap.6.if_true
		jump adjustHeap.7.if_false
	adjustHeap.6.if_true :
		mov $t83(null) $i(null)
		SHL $t83(null) 1
		mov $t84(null) $t83(null)
		ADD $t84(null) 1
		mov $j(null) $t84(null)
		jump adjustHeap.8.if_exit
	adjustHeap.7.if_false :
		jump adjustHeap.8.if_exit
	adjustHeap.8.if_exit :
		mov $t85(null) $i(null)
		SHL $t85(null) 3
		mov $t86(null) Address($a(@a) + 0)
		ADD $t86(null) $t85(null)
		mov $t87(null) $j(null)
		SHL $t87(null) 3
		mov $t88(null) Address($a(@a) + 0)
		ADD $t88(null) $t87(null)
		mov $t90(null) Address($t86(null) + 0)
		cmp $t90(null) Address($t88(null) + 0)
		set GR $t89(null)
		cmp $t89(null) 1
		cjump EQ adjustHeap.9.if_true
		jump adjustHeap.10.if_false
	adjustHeap.9.if_true :
		mov $t91(null) $i(null)
		SHL $t91(null) 3
		mov $t92(null) Address($a(@a) + 0)
		ADD $t92(null) $t91(null)
		mov $t(null) Address($t92(null) + 0)
		mov $t93(null) $i(null)
		SHL $t93(null) 3
		mov $t94(null) Address($a(@a) + 0)
		ADD $t94(null) $t93(null)
		mov $t95(null) $j(null)
		SHL $t95(null) 3
		mov $t96(null) Address($a(@a) + 0)
		ADD $t96(null) $t95(null)
		mov $t97(null) Address($t96(null) + 0)
		mov Address($t94(null) + 0) $t97(null)
		mov $t98(null) $j(null)
		SHL $t98(null) 3
		mov $t99(null) Address($a(@a) + 0)
		ADD $t99(null) $t98(null)
		mov Address($t99(null) + 0) $t(null)
		mov $i(null) $j(null)
		jump adjustHeap.11.if_exit
	adjustHeap.10.if_false :
		jump adjustHeap.12.loop_exit
	adjustHeap.11.if_exit :
		jump adjustHeap.1.loop_condition
	adjustHeap.12.loop_exit :
		ret 0
		jump adjustHeap.13.exit
	adjustHeap.13.exit :
}
func heapSort() { 
	heapSort.0.enter :
		mov $t(null) 0
		mov $k(null) 0
		jump heapSort.1.loop_condition
	heapSort.1.loop_condition :
		cmp $k(null) Address($n(@n) + 0)
		set LE $t35(null)
		cmp $t35(null) 1
		cjump EQ heapSort.2.loop_body
		jump heapSort.4.loop_exit
	heapSort.2.loop_body :
		mov $t36(null) 0
		SHL $t36(null) 3
		mov $t37(null) Address($a(@a) + 0)
		ADD $t37(null) $t36(null)
		mov $t(null) Address($t37(null) + 0)
		mov $t38(null) 0
		SHL $t38(null) 3
		mov $t39(null) Address($a(@a) + 0)
		ADD $t39(null) $t38(null)
		mov $t40(null) Address($n(@n) + 0)
		SUB $t40(null) $k(null)
		mov $t41(null) $t40(null)
		SUB $t41(null) 1
		mov $t42(null) $t41(null)
		SHL $t42(null) 3
		mov $t43(null) Address($a(@a) + 0)
		ADD $t43(null) $t42(null)
		mov $t44(null) Address($t43(null) + 0)
		mov Address($t39(null) + 0) $t44(null)
		mov $t45(null) Address($n(@n) + 0)
		SUB $t45(null) $k(null)
		mov $t46(null) $t45(null)
		SUB $t46(null) 1
		mov $t47(null) $t46(null)
		SHL $t47(null) 3
		mov $t48(null) Address($a(@a) + 0)
		ADD $t48(null) $t47(null)
		mov Address($t48(null) + 0) $t(null)
		mov $t49(null) Address($n(@n) + 0)
		SUB $t49(null) $k(null)
		mov $t50(null) $t49(null)
		SUB $t50(null) 1
		mov $t52(rdi) $t50(null)
		call adjustHeap
		mov $t53(null) $t51(rax)
		jump heapSort.3.loop_next
	heapSort.3.loop_next :
		mov $t54(null) $k(null)
		ADD $t54(null) 1
		mov $k(null) $t54(null)
		jump heapSort.1.loop_condition
	heapSort.4.loop_exit :
		ret 0
		jump heapSort.5.exit
	heapSort.5.exit :
}
func makeHeap() { 
	makeHeap.0.enter :
		mov $t100(null) Address($n(@n) + 0)
		SUB $t100(null) 1
		mov $t101(null) $t100(null)
		SHR $t101(null) 1
		mov $i(null) $t101(null)
		mov $t(null) 0
		mov $j(null) 0
		jump makeHeap.1.loop_condition
	makeHeap.1.loop_condition :
		cmp $i(null) 0
		set GREQ $t102(null)
		cmp $t102(null) 1
		cjump EQ makeHeap.2.loop_body
		jump makeHeap.12.loop_exit
	makeHeap.2.loop_body :
		mov $t103(null) $i(null)
		SHL $t103(null) 1
		mov $j(null) $t103(null)
		mov $t104(null) $i(null)
		SHL $t104(null) 1
		mov $t105(null) $t104(null)
		ADD $t105(null) 1
		cmp $t105(null) Address($n(@n) + 0)
		set LE $t106(null)
		cmp $t106(null) 1
		cjump EQ makeHeap.3.logic_true
		jump makeHeap.4.logic_false
	makeHeap.3.logic_true :
		mov $t108(null) $i(null)
		SHL $t108(null) 1
		mov $t109(null) $t108(null)
		ADD $t109(null) 1
		mov $t110(null) $t109(null)
		SHL $t110(null) 3
		mov $t111(null) Address($a(@a) + 0)
		ADD $t111(null) $t110(null)
		mov $t112(null) $i(null)
		SHL $t112(null) 1
		mov $t113(null) $t112(null)
		SHL $t113(null) 3
		mov $t114(null) Address($a(@a) + 0)
		ADD $t114(null) $t113(null)
		mov $t116(null) Address($t111(null) + 0)
		cmp $t116(null) Address($t114(null) + 0)
		set LE $t115(null)
		mov $t107(null) $t115(null)
		jump makeHeap.5.logic_exit
	makeHeap.4.logic_false :
		mov $t107(null) 0
		jump makeHeap.5.logic_exit
	makeHeap.5.logic_exit :
		cmp $t107(null) 1
		cjump EQ makeHeap.6.if_true
		jump makeHeap.7.if_false
	makeHeap.6.if_true :
		mov $t117(null) $i(null)
		SHL $t117(null) 1
		mov $t118(null) $t117(null)
		ADD $t118(null) 1
		mov $j(null) $t118(null)
		jump makeHeap.8.if_exit
	makeHeap.7.if_false :
		jump makeHeap.8.if_exit
	makeHeap.8.if_exit :
		mov $t119(null) $i(null)
		SHL $t119(null) 3
		mov $t120(null) Address($a(@a) + 0)
		ADD $t120(null) $t119(null)
		mov $t121(null) $j(null)
		SHL $t121(null) 3
		mov $t122(null) Address($a(@a) + 0)
		ADD $t122(null) $t121(null)
		mov $t124(null) Address($t120(null) + 0)
		cmp $t124(null) Address($t122(null) + 0)
		set GR $t123(null)
		cmp $t123(null) 1
		cjump EQ makeHeap.9.if_true
		jump makeHeap.10.if_false
	makeHeap.9.if_true :
		mov $t125(rdi) $i(null)
		mov $t126(rsi) $j(null)
		call exchange $j(null)
		jump makeHeap.11.if_exit
	makeHeap.10.if_false :
		jump makeHeap.11.if_exit
	makeHeap.11.if_exit :
		mov $t127(null) $i(null)
		SUB $t127(null) 1
		mov $i(null) $t127(null)
		jump makeHeap.1.loop_condition
	makeHeap.12.loop_exit :
		ret 0
		jump makeHeap.13.exit
	makeHeap.13.exit :
}
